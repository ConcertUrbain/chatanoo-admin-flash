package org.concert_urbain.touratour.models{    import flash.events.Event;    	// API JSON	import org.concert_urbain.touratour.api.TAT;	import org.concert_urbain.touratour.api.core.events.ServiceEvent;	import org.concert_urbain.touratour.api.core.requests.AbstractServiceRequest;	import org.concert_urbain.touratour.api.vos.*;	import org.concert_urbain.touratour.api.vos.collections.MultiVoCollection;	import org.concert_urbain.touratour.api.vos.collections.VoCollection;	import org.concert_urbain.touratour.api.vos.datas.*;	import org.concert_urbain.touratour.api.vos.events.VoEvent;	import org.concert_urbain.touratour.api.vos.medias.*;		import org.concert_urbain.touratour.events.*;			public class DetailedItemsOfQuery extends ItemsOfQuery	{					// Tableau associatif des datas géoloc. des items (positions géographiques)		protected var datasCartoOfItems:Array;		// Tableau associatif du vote des items (un seul vote)		protected var datasVoteOfItems:Array;		// Tableau associatif des metas des items (mot-clé)		protected var metasOfItems:Array;				// Tableau associatif des utilisateurs des items		protected var userOfItems:Array;				// Tableau associatif des itemIds de chacun des utilisateurs 		protected var itemsOfUsers:Array;				// Tableau linéaire des utilisateurs 		protected var users:Array;				// Tableau associatif des items valides ou non (clé : id)		protected var allItemsVOs:Array;				public function DetailedItemsOfQuery()		{			super();						initModel();		}					override public function initModel():void		{			super.initModel();						// Tableau associatif des données "data" géographiques des items (itemId --> cartoVO)			datasCartoOfItems = new Array();						// Tableau associatif des données "vote" des items (itemId --> voteVO)			datasVoteOfItems = new Array();						// Tableau associatif des données "meta" des items (itemId --> mot-clé)			metasOfItems = new Array();						// Tableau associatif des users des items (itemId --> userVO)			userOfItems = new Array();						// Tableau associatif des items des utilisateurs  (userId --> ids des items)			itemsOfUsers = new Array();						// Tableau linéaire des utilisateurs 			users = new Array();		}						//		// Chargement des Items		//				override public function loadItems():void		{			var ws:TAT = TAT.getInstance();			ws.pluginsService.call("GetItemsWithDetailsByQuery", [queryId]);			ws.addEventListener(ServiceEvent.PLUGINS_CALL_METHOD_SUCCESS, onLoadItems);			ws.addEventListener(ServiceEvent.PLUGINS_CALL_METHOD_ERROR, onLoadItemsError);		}				public function onLoadItemsError(e:ServiceEvent):void		{			var ws:TAT = TAT.getInstance();			ws.removeEventListener(ServiceEvent.PLUGINS_CALL_METHOD_SUCCESS, onLoadItems);			ws.removeEventListener(ServiceEvent.PLUGINS_CALL_METHOD_ERROR, onLoadItemsError);		}				public function onLoadItems(e:ServiceEvent):void		{			var ws:TAT = TAT.getInstance();			ws.removeEventListener(ServiceEvent.PLUGINS_CALL_METHOD_SUCCESS, onLoadItems);			ws.removeEventListener(ServiceEvent.PLUGINS_CALL_METHOD_ERROR, onLoadItemsError);						// Ensemble des items avec leurs données (VO, user, Meta, Data...)			var allItemsInfos:Array = e.result as Array;			var i:uint;			var n:uint = allItemsInfos.length;			var infosItem:Object;									// Tableau linéaire des items (validés)			items = new Array();						// Tableau associatif des items (validés)			itemsVOs = new Array();						// Tableau associatif des items (validés ou non)			allItemsVOs = new Array();			var itemVO:Item;			var itemId:int;			var itemRate:Number;						var userVO:User;			var userId:int;			var metas:Array;			var datas:Object;						var itemIdStr:String;			var userIdStr:String;						// Permet de contrôler que l'on ne met pas plusieurs fois le même utilisateur			var userIds:Array = new Array();						for (i=0;i<n;i++) {								infosItem = allItemsInfos[i];								itemVO = infosItem['VO'];												//				// On n'affiche que les items valides				//								userVO = infosItem['user'];				itemRate = infosItem['rate'];				metas = infosItem['metas'] as Array;				datas = infosItem['datas'] as Object;				itemId = itemVO.id;								// Sert aux tableaux associatifs				itemIdStr = keyFor(itemId);								// Vote				// TODO_JSON				itemVO.rate = itemRate;														if (itemVO.isValid)				{					// Liste linéaire des items valides					items.push(itemVO);									// Tableau associatif des items					itemsVOs[itemIdStr] = itemVO;				}				// Tableau associatif des items valides ou non valides				// RQ : sert à mon compte				allItemsVOs[itemIdStr] = itemVO;												// Tableau associatif des metas (mots-clés)				metasOfItems[itemIdStr] = metas;								// Tableau associatif des datas géographiques des items (positions)				datasCartoOfItems[itemIdStr] = datas['Carto'];								// Tableau associatif des datas votes des items				datasVoteOfItems[itemIdStr] = datas['Vote'];												// Utilisateurs 				if (userVO is User)				{					userId = userVO.id;									if (userIds.indexOf(userId) == - 1)					{						userIds.push(userId);												// Tableau linéaire des utilisateurs						users.push(userVO);					}										addUserForItem(userVO, itemId);				}			}						dispatchEvent(new Event(ItemsOfQuery.ITEMS_LOADED));		}		public function getItemByIdValidAndNotValid(id:int):Item		{			// Tableau assocatif des items valides ou non			return allItemsVOs[keyFor(id)];		}		public function getDatasCartoOfItem(itemId:int):Array		{			return datasCartoOfItems[keyFor(itemId)];		}				public function getDatasVoteOfItem(itemId:int):Array		{			return datasVoteOfItems[keyFor(itemId)];		}						public function getMetasOfItem(itemId:int):Array		{			return metasOfItems[keyFor(itemId)];		}				public function getUserOfItem(itemId:int):User		{			return userOfItems[keyFor(itemId)];		}				// Retourne la liste des VOs des utilisateurs		public function getUsers():Array		{			return users;		}				// Retourne la liste des ids des items d'un user :		public function getItemIdsOfUser(userId:int):Array		{			return itemsOfUsers[keyFor(userId)];		}		// Retourne la liste des items associé à une meta donnée:		public function getItemsWithMeta(metaId:int):Array		{			var i:int;			var item:Item;			var itemsWithMeta:Array = new Array();						if (items)			{				var n:int = items.length;								for (i=0; i<n; i++)				{					item = items[i] as Item;					if (item)					{						if (item.isValid)						{							var itemId:int = item.id;							var meta:Meta;														var metas:Array = getMetasOfItem(itemId);							if (metas is Array)							{								var j:int;								var m:int = metas.length;																for (j=0; j<m; j++)								{									meta = metas[j] as Meta;									if (meta)									{										if (meta.id == metaId)										{											itemsWithMeta.push(item);											break;										}									}								}							}						}					}				}			}						return itemsWithMeta;		}		//		// Ajout de données		//				public function addDatasCartoForItem(itemCartoDataVO:CartoData, itemId:int):void		{			var itemIdStr:String = keyFor(itemId);						// Tableau associatif			if (datasCartoOfItems[itemIdStr] is Array)			{				datasCartoOfItems[itemIdStr].push(itemCartoDataVO);			}			else			{				datasCartoOfItems[itemIdStr] = [itemCartoDataVO];			}		}				public function addDatasVoteForItem(itemVoteDataVO:VoteData, itemId:int):void		{			var itemIdStr:String = keyFor(itemId);						// Tableau associatif			if (datasVoteOfItems[itemIdStr] is Array)			{				datasVoteOfItems[itemIdStr].push(itemVoteDataVO);			}			else			{				datasVoteOfItems[itemIdStr] = [itemVoteDataVO];			}		}		//		// Ajout de meta-données		//		public function removeMetaForItem(metaId:int, itemId:int):Boolean		{			// Tableau associatif			var itemIdStr:String = keyFor(itemId);			var metas:Array = metasOfItems[itemIdStr];						if (metas is Array)			{				var i:int;				var n:int = metas.length;				var metaVO:Meta;				for (i=0; i<n; i++)				{					metaVO = metas[i];										if (metaVO.id == metaId)					{						metas.splice(i, 1);						return true;					}				}			}						return false;		}				public function addMetasForItem(itemMetaVO:Meta, itemId:int):void		{			var itemIdStr:String = keyFor(itemId);						// Tableau associatif			if (metasOfItems[itemIdStr] is Array)			{				metasOfItems[itemIdStr].push(itemMetaVO);			}			else			{				metasOfItems[itemIdStr] = [itemMetaVO];			}		}				public function addUser(userVO:User):void		{			var userId:int = userVO.id;						var userIds:Array = new Array();			var i:int;			var n:int = users.length;			var user:User;						for (i=0; i<n; i++)			{				user = users[i];				userIds.push(user.id);			}						//						if (userIds.indexOf(userId) == -1)			{				users.push(userVO);				userIds.push(userId);			}		}				public function addUserForItem(userVO:User, itemId:int):void		{			var itemIdStr:String = keyFor(itemId);			var userIdStr:String = keyFor(userVO.id);			// Tableau associatif des utilisateurs (itemId --> userVO)			userOfItems[itemIdStr] = userVO;			// Tableau associatif (userId --> Array des ids des items de l'utilisateur)			var userVos:Array = itemsOfUsers[userIdStr];						if (userVos == null)			{				userVos = itemsOfUsers[userIdStr] = new Array();			}						userVos.push(itemId);		}	}}